<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>General Detector Helper ‚Äì PWA</title>
  <meta name="theme-color" content="#0b0f14">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icon-gd-192.png" sizes="192x192">
  <link rel="apple-touch-icon" href="icon-gd-512.png">
  <style>
    :root{--bg:#0b0f14;--panel:#101621;--muted:#8aa0b9;--text:#e7f1ff;--accent:#42d6a4;--danger:#ff6b6b;--line:#1c2736}
    *{box-sizing:border-box}html,body{height:100%}
    body{margin:0;background:linear-gradient(180deg,#0b0f14 0%,#0d131d 100%);color:var(--text);font:16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
    header{display:flex;align-items:center;justify-content:space-between;padding:14px 18px;background:rgba(9,13,20,.7);border-bottom:1px solid var(--line);position:sticky;top:0;z-index:20}
    .brand{font-weight:800;letter-spacing:.2px}
    .iconbtn{appearance:none;border:1px solid var(--line);background:#0e1520;color:var(--text);border-radius:10px;padding:8px 10px;display:flex;gap:8px;align-items:center;cursor:pointer}
    .wrap{max-width:860px;margin:0 auto;padding:22px 16px 64px}
    .card{background:var(--panel);border:1px solid var(--line);border-radius:16px;box-shadow:0 12px 30px rgba(0,0,0,.25)}
    .home{padding:26px}
    .biggrid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
    .bigbtn{border:none;border-radius:16px;padding:26px;cursor:pointer;color:#04120d;font-weight:900;font-size:20px}
    .bigbtn:disabled{opacity:.5;cursor:not-allowed;filter:grayscale(20%)}
    .rec{background:linear-gradient(180deg,#ff9aa6,#ff6b6b)}
    .listen{background:linear-gradient(180deg,#6de1b7,#42d6a4)}
    .muted{color:var(--muted);font-size:13px}
    .status{margin-top:10px;font-size:14px;min-height:1.6em}
    dialog{border:1px solid var(--line);border-radius:14px;padding:18px;background:#0c1118;color:var(--text);max-width:480px;width:clamp(280px,90vw,480px)}
    dialog::backdrop{background:rgba(0,0,0,.5)}
    input[type="range"],input[type="text"]{width:100%;padding:10px 12px;border-radius:10px;border:1px solid var(--line);background:#0c1118;color:var(--text)}
    .toolbar{display:flex;gap:10px;align-items:center;margin-top:12px}
    .btn{appearance:none;border:1px solid var(--line);background:#0f1622;color:#e7f1ff;border-radius:12px;padding:10px 14px;cursor:pointer;font-weight:700}
    .btn.primary{background:linear-gradient(180deg,#6de1b7,#42d6a4);color:#06231a;border:none}
    .btn.danger{background:linear-gradient(180deg,#ffa3a3,#ff6b6b);border:none;color:#3a0a0a}
    footer{opacity:.8;text-align:center;margin-top:18px}
  </style>
</head>
<body>
<header>
  <div class="brand">General Detector Helper ‚Äî PWA Offline</div>
  <button id="settingsBtn" class="iconbtn">‚öôÔ∏è <span class="muted" style="font-size:13px">Settaggi</span></button>
</header>

<div class="wrap">
  <section class="card home" id="home">
    <h2>Seleziona modalit√†</h2>
    <div class="biggrid">
      <button id="recBtn" class="bigbtn rec">‚óè Registra</button>
      <button id="listenBtn" class="bigbtn listen">‚ñ∂Ô∏é Ascolta</button>
    </div>
    <div class="status muted" id="status">Funziona <b>offline</b> (in PWA/HTTPS). I campioni vengono salvati nella libreria privata <b>general-detector-lib</b>.</div>
<canvas id="waveCanvas" width="800" height="150" style="width:100%;margin-top:12px;background:#0e1520;border-radius:8px"></canvas>
  </section>
  <footer class="muted">¬© 2025 ‚Äì Menu ‚ãÆ ‚Üí ‚ÄúAggiungi a schermata Home‚Äù</footer>
</div>

<dialog id="saveDialog">
  <h3>Nome file da salvare</h3>
  <input id="fileName" type="text" placeholder="Es. Moneta, Anello, Chiodo"/>
  <div class="toolbar" style="justify-content:flex-end">
    <button id="cancelSave" class="btn">Annulla</button>
    <button id="confirmSave" class="btn primary">Salva</button>
  </div>
</dialog>

<dialog id="settingsDialog">
  <h3>Impostazioni</h3>
  <label class="muted">Soglia evento (RMS)</label>
  <input type="range" id="threshold" min="0.02" max="0.2" step="0.005" value="0.08"/>
  <div class="muted">Valore: <span id="threshLbl">0.08</span></div>
  <label class="muted" style="margin-top:8px;display:block">Durata finestra campione (ms)</label>
  <input type="range" id="winSize" min="200" max="1200" step="50" value="500"/>
  <div class="muted">Valore: <span id="winLbl">500</span> ms</div>  <label class="muted" style="margin-top:8px;display:block">Preset durata campione</label>  <select id="winPreset" class="btn" style="width:100%">    <option value="200">200 ms</option>    <option value="350">350 ms</option>    <option value="500" selected>500 ms</option>    <option value="800">800 ms</option>    <option value="1000">1000 ms</option>    <option value="1200">1200 ms</option>  </select>
  <label class="muted" style="margin-top:8px;display:block">Soglia di similarit√†</label>
  <input type="range" id="simThresh" min="0.5" max="0.98" step="0.01" value="0.85"/>
  <div class="muted">Valore: <span id="simLbl">0.85</span></div>
  <div class="toolbar" style="justify-content:space-between;margin-top:12px">    <button id="wipeLib" class="btn danger">Cancella TUTTO</button>    <button id="closeSettings" class="btn">Chiudi</button>  </div>
</dialog>

<script>
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('./sw.js').catch(console.error);
  });
}

(() => {
  const recBtn = document.getElementById('recBtn');
  const listenBtn = document.getElementById('listenBtn');
  const statusEl = document.getElementById('status');
  const settingsDialog = document.getElementById('settingsDialog');
  const thresholdInp = document.getElementById('threshold');
  const winSizeInp = document.getElementById('winSize');
  const simThreshInp = document.getElementById('simThresh');
  const threshLbl = document.getElementById('threshLbl');
  const winLbl = document.getElementById('winLbl');
  const simLbl = document.getElementById('simLbl');
  // New UI elements
  const winPreset = document.getElementById('winPreset');
  const wipeLibBtn = document.getElementById('wipeLib');

  // Track sample rate for the last recorded buffer
  let recSampleRate = 44100;

  // Save/Cancel handlers to prevent blocking
  if(confirmSave) confirmSave.onclick = async () => {
    try{
      if(!lastEventBuffer){ setStatus('Nessun campione da salvare.'); safeCloseDialog(saveDialog); return; }
      const blob = encodeWavPCM16(lastEventBuffer, recSampleRate||44100);
      const saved = await saveWavToLibrary(fileName.value, blob);
      setStatus('‚úîÔ∏è Salvato: ' + saved);
      lastEventBuffer = null;
      fileName.value = '';
      safeCloseDialog(saveDialog);
    }catch(err){
      setStatus('Errore salvataggio: '+err.message);
      try{ safeCloseDialog(saveDialog); }catch{}
    }
  };
  if(cancelSave) cancelSave.onclick = () => {
    lastEventBuffer = null;
    fileName.value='';
    setStatus('‚ùé Salvataggio annullato');
    try{ safeCloseDialog(saveDialog); }catch{}
  };

  // Clear library with confirmation
  async function clearLibrary(){
    try{
      const dir = await ensureLibrary();
      const toDelete = [];
      for await (const entry of dir.values()){
        if(entry.kind==='file' && entry.name.toLowerCase().endsWith('.wav')) toDelete.push(entry.name);
      }
      for (const name of toDelete){
        await dir.removeEntry(name);
      }
      setStatus('üóëÔ∏è Libreria svuotata ('+toDelete.length+' file).');
    }catch(err){
      setStatus('Errore durante cancellazione: '+err.message);
    }
  }
  if(wipeLibBtn){ wipeLibBtn.addEventListener('click', async ()=>{
    const ok = window.confirm('Confermi? Questa azione canceller√† TUTTI i campioni salvati (irreversibile).');
    if(ok) await clearLibrary();
  });

  // Sync preset select with slider and label
  function updateWinFromSlider(){
    const v = parseInt(winSizeInp.value,10);
    winLbl.textContent = v;
    // Set the select to the closest option
    const opts = Array.from(winPreset.options).map(o=>parseInt(o.value,10));
    let closest = opts[0], diff = Math.abs(v-opts[0]);
    for(const o of opts){ const d=Math.abs(v-o); if(d<diff){ diff=d; closest=o; } }
    winPreset.value = String(closest);
  }
  function updateSliderFromPreset(){
    winSizeInp.value = winPreset.value;
    winLbl.textContent = winPreset.value;
  }
  winSizeInp.addEventListener('input', updateWinFromSlider);
  winPreset.addEventListener('change', updateSliderFromPreset);


  const saveDialog = document.getElementById('saveDialog');
  const fileName = document.getElementById('fileName');
  const confirmSave = document.getElementById('confirmSave');
  const cancelSave = document.getElementById('cancelSave');
  // Helpers for dialogs (polyfill behavior)
  function safeShowDialog(d){
    try{
      if(d && typeof d.showModal === 'function') d.showModal();
      else if(d) d.setAttribute('open','open');
    }catch(err){ setStatus('Errore apertura finestra: '+err.message); }
  }
  function safeCloseDialog(d){
    try{
      if(d && typeof d.close === 'function') d.close();
      else if(d) d.removeAttribute('open');
    }catch{}
  }
  function dbg(msg){ try{ setStatus('[DBG] '+msg); }catch{} }

  const waveCanvas = document.getElementById('waveCanvas');
  const waveCtx = waveCanvas ? waveCanvas.getContext('2d') : null;

  function drawWaveform(data){
    if(!waveCtx || !data) return;
    const w = waveCanvas.width, h = waveCanvas.height;
    waveCtx.clearRect(0,0,w,h);
    waveCtx.beginPath();
    const step = Math.max(1, Math.ceil(data.length / w));
    const mid = h / 2;
    for(let x=0; x<w; x++){
      let min=1, max=-1;
      const base = x*step;
      for(let j=0; j<step; j++){
        const v = data[base+j] || 0;
        if(v<min) min=v;
        if(v>max) max=v;
      }
      waveCtx.moveTo(x, mid + min*mid);
      waveCtx.lineTo(x, mid + max*mid);
    }
    waveCtx.strokeStyle = '#42d6a4';
    waveCtx.lineWidth = 2;
    waveCtx.stroke();
  }


  let recActive=false, listenActive=false;
  let acRec=null, acLis=null, procRec=null, procLis=null, streamRec=null, streamLis=null;
  let lastEventBuffer=null;

  function setStatus(t){ statusEl.innerHTML=t; }
  function refreshModeUI(){ recBtn.disabled = !!listenActive; listenBtn.disabled = !!recActive; }

  let libraryDirHandle=null;
  async function ensureLibrary(){
    if(libraryDirHandle) return libraryDirHandle;
    if(!(navigator.storage && navigator.storage.getDirectory)){
      throw new Error('OPFS non supportato dal browser');
    }
    const root = await navigator.storage.getDirectory();
    libraryDirHandle = await root.getDirectoryHandle('general-detector-lib', {create:true});
    return libraryDirHandle;
  }
  async function listWavs(){
    const dir = await ensureLibrary();
    const out=[];
    for await (const entry of dir.values()){
      if(entry.kind==='file' && entry.name.toLowerCase().endsWith('.wav')) out.push(entry);
    }
    return out;
  }
  async function saveWavToLibrary(basename, blob){
    const dir = await ensureLibrary();
    const name = (basename && basename.trim()) ? basename.trim() : 'SenzaNome';
    const fh = await dir.getFileHandle(name + '.wav', {create:true});
    const ws = await fh.createWritable();
    await ws.write(blob); await ws.close();
    return name + '.wav';
  }

  function floatTo16PCM(arr){
    const n=arr.length, buf=new ArrayBuffer(n*2), v=new DataView(buf);
    for(let i=0;i<n;i++){ let s=arr[i]; if(s>1) s=1; if(s<-1) s=-1; v.setInt16(i*2, s<0 ? s*32768 : s*32767, true); }
    return new Uint8Array(buf);
  }
  function encodeWavPCM16(mono, rate){
    const pcm=floatTo16PCM(mono);
    const dataSize=pcm.byteLength, chunkSize=36+dataSize;
    const hdr=new ArrayBuffer(44), v=new DataView(hdr);
    function W(o,s){ for(let i=0;i<s.length;i++) v.setUint8(o+i, s.charCodeAt(i)); }
    W(0,'RIFF'); v.setUint32(4,chunkSize,true); W(8,'WAVE'); W(12,'fmt ');
    v.setUint32(16,16,true); v.setUint16(20,1,true); v.setUint16(22,1,true);
    v.setUint32(24,rate,true); v.setUint32(28,rate*2,true); v.setUint16(32,2,true); v.setUint16(34,16,true);
    W(36,'data'); v.setUint32(40,dataSize,true);
    return new Blob([hdr, pcm], {type:'audio/wav'});
  }

  function hann(buf){ const n=buf.length, out=new Float32Array(n); for(let i=0;i<n;i++){ const w=0.5-0.5*Math.cos(2*Math.PI*i/(n-1)); out[i]=buf[i]*w; } return out; }
  async function bufferToSpectrum(mono, rate){
    const len=mono.length; const p2 = 1<<Math.ceil(Math.log2(len));
    const pad=new Float32Array(p2); pad.set(hann(mono));
    const off=new OfflineAudioContext(1,p2,rate);
    const ab=off.createBuffer(1,p2,rate); ab.copyToChannel(pad,0,0);
    const src=off.createBufferSource(); src.buffer=ab;
    const an=off.createAnalyser(); an.fftSize=Math.min(32768,p2*2);
    const g=off.createGain(); src.connect(an); an.connect(g); g.connect(off.destination);
    src.start(); await off.startRendering();
    const bins=an.frequencyBinCount; const arr=new Float32Array(bins); an.getFloatFrequencyData(arr);
    const mags=new Float32Array(bins); let mx=-1;
    for(let i=0;i<bins;i++){ const lin=Math.pow(10,arr[i]/20); mags[i]=lin; if(lin>mx) mx=lin; }
    if(mx>0){ for(let i=0;i<bins;i++) mags[i]/=mx; }
    const lo=10, hi=Math.floor(bins*0.6); return mags.slice(lo,hi);
  }
  function cosineSim(a,b){
    const n=Math.min(a.length,b.length); let dot=0,na=0,nb=0;
    for(let i=0;i<n;i++){ const x=a[i], y=b[i]; dot+=x*y; na+=x*x; nb+=y*y; }
    if(na===0||nb===0) return 0; return dot/Math.sqrt(na*nb);
  }

  async function startRecording(){
    if(listenActive){ setStatus('‚ùå Ferma ‚ÄúAscolta‚Äù prima di registrare.'); return; }
    if(acRec){ acRec.close(); acRec=null; }
    acRec = new (window.AudioContext||window.webkitAudioContext)();
    recSampleRate = acRec.sampleRate;
    const stream = await navigator.mediaDevices.getUserMedia({audio:true});
    streamRec=stream;
    const src=acRec.createMediaStreamSource(stream);
    const sp=acRec.createScriptProcessor(2048,1,1); procRec=sp;
    src.connect(sp); sp.connect(acRec.destination);
    const thresh=parseFloat(thresholdInp.value||'0.08');
    const winMs=Math.max(200, Math.min(1200, parseInt(winSizeInp.value||'500',10)));
    let collector=null;
    sp.onaudioprocess=(e)=>{
      const ch=e.inputBuffer.getChannelData(0); drawWaveform(ch);
      let s=0; for(let i=0;i<ch.length;i++) s+=ch[i]*ch[i];
      const rms=Math.sqrt(s/ch.length);
      if(!recActive) return;
      if(rms>=thresh){
        const need=Math.floor(acRec.sampleRate*(winMs/1000));
        if(!collector) collector={buf:new Float32Array(need), idx:0};
        const copy=Math.min(ch.length, need-collector.idx);
        collector.buf.set(ch.subarray(0,copy), collector.idx); collector.idx+=copy;
        if(collector.idx>=need){
          lastEventBuffer=collector.buf;
          setStatus('Campione acquisito. Premi ‚ÄúRegistra‚Äù di nuovo per fermare e salvare.');
          collector=null;
        }
      } else {
        if(collector && collector.idx< (collector.buf.length*0.25)) collector=null;
      }
    };
    setStatus('Registrazione attiva: attendi evento sopra soglia‚Ä¶');
  }
  function stopRecording(){
    if(procRec){procRec.disconnect(); procRec.onaudioprocess=null; procRec=null;}
    if(streamRec){streamRec.getTracks().forEach(t=>t.stop()); streamRec=null;}
    if(acRec){acRec.close(); acRec=null;}
  }

  async function buildLibrarySpectra(){
    const entries=await listWavs(); const out=[];
    for(const e of entries){
      const f=await e.getFile(); const ab=await f.arrayBuffer();
      const ctx=new (window.AudioContext||window.webkitAudioContext)();
      const buf=await ctx.decodeAudioData(ab.slice(0));
      const ch=buf.getChannelData(0);
      const spec=await bufferToSpectrum(ch, buf.sampleRate);
      out.push({name:e.name.replace(/\.wav$/i,''), spec});
      ctx.close();
    }
    return out;
  }
  async function startListening(){
    if(recActive){ setStatus('‚ùå Ferma ‚ÄúRegistra‚Äù prima di ascoltare.'); return; }
    const lib=await buildLibrarySpectra();
    setStatus('Ascolto attivo‚Ä¶ Libreria: '+lib.length+' file');
    if(lib.length===0) setStatus('Nessun file in general-detector-lib. Registra prima un campione.');
    if(acLis){ acLis.close(); acLis=null; }
    acLis = new (window.AudioContext||window.webkitAudioContext)();
    const stream=await navigator.mediaDevices.getUserMedia({audio:true});
    streamLis=stream;
    const src=acLis.createMediaStreamSource(stream);
    const sp=acLis.createScriptProcessor(2048,1,1); procLis=sp;
    src.connect(sp); sp.connect(acLis.destination);
    const simThresh=parseFloat(simThreshInp.value||'0.85');
    const eventRMS=parseFloat(thresholdInp.value||'0.08');
    const winMs=Math.max(200, Math.min(1200, parseInt(winSizeInp.value||'500',10)));
    let collector=null;
    sp.onaudioprocess=async (e)=>{
      const ch=e.inputBuffer.getChannelData(0); drawWaveform(ch);
      let s=0; for(let i=0;i<ch.length;i++) s+=ch[i]*ch[i];
      const rms=Math.sqrt(s/ch.length);
      if(!listenActive) return;
      if(rms>=eventRMS){
        const need=Math.floor(acLis.sampleRate*(winMs/1000));
        if(!collector) collector={buf:new Float32Array(need), idx:0};
        const copy=Math.min(ch.length, need-collector.idx);
        collector.buf.set(ch.subarray(0,copy), collector.idx); collector.idx+=copy;
        if(collector.idx>=need){
          const evtSpec=await bufferToSpectrum(collector.buf, acLis.sampleRate);
          let bestName='Sconosciuto', bestSim=0;
          for(const p of lib){ const sim=cosineSim(evtSpec, p.spec); if(sim>bestSim){ bestSim=sim; bestName=p.name; } }
          if(bestSim>=simThresh) setStatus('Match: '+bestName+' ('+(bestSim*100).toFixed(1)+'%)');
          else setStatus('Sconosciuto (best '+(bestSim*100).toFixed(1)+'%)');
          collector=null;
        }
      } else {
        if(collector && collector.idx < (collector.buf.length*0.25)) collector=null;
      }
    };
  }
  function stopListening(){
    if(procLis){procLis.disconnect(); procLis.onaudioprocess=null; procLis=null;}
    if(streamLis){streamLis.getTracks().forEach(t=>t.stop()); streamLis=null;}
    if(acLis){acLis.close(); acLis=null;}
  }

  recBtn.onclick = async ()=>{ dbg('click Registra'); setStatus('‚ñ∂Ô∏è Bottone Registra premuto');
    if(listenActive){ setStatus('‚ùå Ferma ‚ÄúAscolta‚Äù prima di registrare.'); return; }
    if(!recActive){
      recActive = true; refreshModeUI(); recBtn.textContent='‚ñ† Ferma';
      try{ await ensureLibrary(); await startRecording(); }
      catch(err){ setStatus('Errore: '+err.message); recActive=false; refreshModeUI(); recBtn.textContent='‚óè Registra'; }
    }else{
      recActive = false; refreshModeUI(); recBtn.textContent='‚óè Registra';
      stopRecording();
      if(lastEventBuffer){ safeShowDialog(saveDialog); setStatus('Campione pronto. Inserisci il nome e salva.'); }
      else { setStatus('Nessun campione catturato.'); }
    }
  };

  listenBtn.onclick = async ()=>{ dbg('click Ascolta'); setStatus('‚ñ∂Ô∏è Bottone Ascolta premuto');
    if(recActive){ setStatus('‚ùå Ferma ‚ÄúRegistra‚Äù prima di ascoltare.'); return; }
    if(!listenActive){
      listenActive = true; refreshModeUI(); listenBtn.textContent='‚ñ† Stop';
      try{ await ensureLibrary(); await startListening(); }
      catch(err){ setStatus('Errore: '+err.message); listenActive=false; refreshModeUI(); listenBtn.textContent='‚ñ∂Ô∏é Ascolta'; }
    }else{
      listenActive = false; refreshModeUI(); listenBtn.textContent='‚ñ∂Ô∏é Ascolta';
      stopListening(); setStatus('Ascolto fermato');
    }
  };

  document.getElementById('settingsBtn').onclick = ()=> safeShowDialog(settingsDialog);
  document.getElementById('closeSettings').onclick = ()=> safeCloseDialog(settingsDialog);
  thresholdInp.oninput=()=>{threshLbl.textContent=parseFloat(thresholdInp.value).toFixed(3);};
  winSizeInp.oninput=()=>{winLbl.textContent=parseInt(winSizeInp.value,10);};
  simThreshInp.oninput=()=>{simLbl.textContent=parseFloat(simThreshInp.value).toFixed(2);};

  refreshModeUI();
  setStatus('Pronto. Usa una modalit√† alla volta.');
})();
</script>
</body>
</html>
