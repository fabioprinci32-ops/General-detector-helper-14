<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>General Detector Helper — PWA</title>
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0b1220">
  <style>
    :root { --bg:#0b1220; --fg:#e8eefc; --muted:#94a3b8; --accent:#60a5fa; --danger:#ef4444; --ok:#22c55e; }
    * { box-sizing:border-box; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif }
    body { margin:0; background:var(--bg); color:var(--fg) }
    header, footer { padding:16px; display:flex; align-items:center; justify-content:space-between }
    h1 { font-size:18px; margin:0 }
    .gear { cursor:pointer; font-size:14px; color:var(--muted) }
    main { padding:16px; max-width:920px; margin:0 auto }
    .row { display:flex; gap:12px; flex-wrap:wrap; align-items:center }
    .card { background:#111827; border:1px solid #1f2937; border-radius:16px; padding:16px }
    button { background:#111827; color:var(--fg); border:1px solid #1f2937; border-radius:999px; padding:10px 16px; cursor:pointer }
    button.primary { background:var(--accent); color:#0b1220; border-color:transparent }
    button.danger { background:var(--danger); color:white; border-color:transparent }
    button:disabled { opacity:.5; cursor:not-allowed }
    .mode { gap:8px }
    .dot { width:10px; height:10px; border-radius:50%; display:inline-block; background:#374151; margin-right:6px }
    .dot.live { background:#22c55e; box-shadow:0 0 12px #22c55e }
    .pill { background:#101826; border:1px solid #1f2937; padding:8px 10px; border-radius:999px; color:#94a3b8 }
    canvas { width:100%; height:160px; background:#0b0f1a; border-radius:12px; border:1px solid #1f2937 }
    label { color:#cbd5e1; font-size:14px }
    input[type="number"], input[type="text"] { width:100%; padding:10px 12px; border-radius:10px; border:1px solid #1f2937; background:#0f172a; color:var(--fg) }
    .grid { display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:10px }
    dialog { border:none; border-radius:16px; padding:0 }
    dialog::backdrop { background:rgba(0,0,0,.6) }
    .dlg { background:#0f172a; color:var(--fg); padding:16px; border-radius:16px; min-width:320px }
    .dlg h3 { margin:0 0 12px 0; font-size:18px }
    .spacer { flex:1 }
    .hint { color:var(--muted); font-size:13px }
    ul.files { list-style:none; padding:0; margin:0; max-height:160px; overflow:auto }
    ul.files li { padding:6px 0; border-bottom:1px dashed #1f2937; font-size:14px; color:#cbd5e1 }
    .badge { padding:4px 8px; border-radius:999px; border:1px solid #1f2937; background:#0d1424; color:#cbd5e1; font-size:12px }
    .matchbar { display:flex; gap:10px; align-items:center; margin-top:8px }
    .meter { flex:1; height:10px; border-radius:8px; background:#0b0f1a; border:1px solid #1f2937; overflow:hidden }
    .meter > div { height:100%; background:linear-gradient(90deg,#60a5fa,#22c55e); width:0% }
  </style>
</head>
<body>
  <header>
    <h1>General Detector Helper — PWA</h1>
    <div class="row">
      <span class="pill">Funziona offline</span>
      <span id="btn-settings" class="gear">⚙️ Settaggi</span>
    </div>
  </header>

  <main class="card">
    <section class="row mode">
      <strong>Seleziona modalità</strong>
      <button id="btn-record" class="primary">● Registra</button>
      <button id="btn-listen">▶︎ Ascolta (riconoscimento)</button>
      <button id="btn-stop">■ Stop</button>
      <span class="spacer"></span>
      <span><span id="live-dot" class="dot"></span><small class="hint">stato</small></span>
    </section>

    <section style="margin-top:12px">
      <canvas id="scope" width="1400" height="240"></canvas>
      <div class="row" style="margin-top:8px">
        <div class="pill">Segnale in ingresso</div>
        <div id="level" class="pill">RMS: 0.00</div>
        <div id="libcount" class="pill">Libreria: 0</div>
      </div>
      <div class="matchbar">
        <span id="match-name" class="badge">—</span>
        <div class="meter"><div id="match-meter"></div></div>
        <span id="match-score" class="badge">0.00</span>
      </div>
    </section>

    <section class="card" style="margin-top:12px">
      <div class="row">
        <div style="flex:1">
          <label>Durata finestra campione (ms)</label>
          <input id="sample-ms" type="number" min="50" step="50" value="500">
          <div class="grid" style="margin-top:8px">
            <button class="preset" data-ms="200">200 ms</button>
            <button class="preset" data-ms="350">350 ms</button>
            <button class="preset" data-ms="500">500 ms</button>
            <button class="preset" data-ms="800">800 ms</button>
            <button class="preset" data-ms="1000">1000 ms</button>
            <button class="preset" data-ms="1200">1200 ms</button>
          </div>
        </div>
        <div style="flex:1">
          <label>Soglia evento (RMS)</label>
          <input id="thr" type="number" min="0.01" max="1" step="0.01" value="0.08">
          <label style="margin-top:10px; display:block">Soglia match (0–1)</label>
          <input id="match-thr" type="number" min="0.3" max="0.99" step="0.01" value="0.85">
          <p class="hint" style="margin:.5rem 0 0">
            In “Ascolta” quando RMS supera la soglia, il segmento viene confrontato con i campioni salvati.
          </p>
        </div>
      </div>
    </section>

    <section class="card" style="margin-top:12px">
      <div class="row">
        <strong>Libreria (OPFS)</strong>
        <span class="spacer"></span>
        <button id="btn-reload-lib">Ricarica libreria</button>
        <button id="btn-delete-all" class="danger">Cancella TUTTO</button>
      </div>
      <ul id="file-list" class="files"></ul>
    </section>
  </main>

  <footer>
    <small class="hint">© 2025 — Aggiungi alla schermata Home dal menu del browser</small>
  </footer>

  <!-- Dialog Salvataggio -->
  <dialog id="dlg-save">
    <div class="dlg">
      <h3>Nome file da salvare</h3>
      <input id="save-name" type="text" placeholder="es. target-ferroso-A">
      <div class="row" style="margin-top:12px; justify-content:flex-end">
        <button id="btn-cancel-save">Annulla</button>
        <button id="btn-do-save" class="primary">Salva</button>
      </div>
    </div>
  </dialog>

  <!-- Dialog Settaggi -->
  <dialog id="dlg-settings">
    <div class="dlg">
      <h3>Impostazioni</h3>
      <p class="hint">Qui verranno aggiunte impostazioni avanzate.</p>
      <div class="row" style="justify-content:flex-end">
        <button id="btn-close-settings" class="primary">Chiudi</button>
      </div>
    </div>
  </dialog>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').catch(console.warn);
      });
    }

    let audioCtx, analyser, mediaStream, source, mediaRecorder, chunks = [];
    let runningMode = null;
    let rafId = null;

    let opfsRoot, libDir;
    const LIB_DIR = 'general-detector-lib';

    const FPT_LEN = 64;
    const LP_MS = 5;
    const MAX_SHIFT = 8;
    const library = [];

    
const btnStop = document.getElementById('btn-stop');

function stopAll() {
  if (rafId){ cancelAnimationFrame(rafId); rafId=null; }
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    try { mediaRecorder.stop(); } catch(_) {}
  }
  setLive(false);
  runningMode = null;
  btnRecord.disabled = false; 
  btnListen.disabled = false;
  btnListen.textContent = '▶︎ Ascolta (riconoscimento)';
  btnRecord.textContent = '● Registra';
}

btnListen.addEventListener('click', async ()=>{
  if (runningMode === 'listen') {
    stopAll();
    return;
  }
  setMode('listen');
  btnListen.textContent = '⏸️ Ferma ascolto';
  try { await startListen(); } catch (e) { console.error(e); alert('Accesso microfono negato o non disponibile.'); stopAll(); }
});

btnRecord.addEventListener('click', async ()=>{
  if (runningMode === 'record') {
    stopAll();
    return;
  }
  if (runningMode === 'listen') return;
  setMode('record');
  btnRecord.textContent = '⏸️ Ferma registrazione';
  try { await startRecord(); } catch (e) { console.error(e); alert('Accesso microfono negato o non disponibile.'); stopAll(); }
});

btnStop.addEventListener('click', ()=>{ stopAll(); });
document.addEventListener('visibilitychange', ()=>{ if (document.hidden) stopAll(); });

const btnRecord = document.getElementById('btn-record');
    const btnListen = document.getElementById('btn-listen');
    const liveDot = document.getElementById('live-dot');
    const scope = document.getElementById('scope');
    const level = document.getElementById('level');
    const libcount = document.getElementById('libcount');
    const ctx2d = scope.getContext('2d');
    const thrEl = document.getElementById('thr');
    const msEl = document.getElementById('sample-ms');
    const matchThrEl = document.getElementById('match-thr');
    const fileList = document.getElementById('file-list');
    const dlgSave = document.getElementById('dlg-save');
    const saveName = document.getElementById('save-name');
    const btnDoSave = document.getElementById('btn-do-save');
    const btnCancelSave = document.getElementById('btn-cancel-save');
    const btnDeleteAll = document.getElementById('btn-delete-all');
    const btnReloadLib = document.getElementById('btn-reload-lib');
    const btnSettings = document.getElementById('btn-settings');
    const dlgSettings = document.getElementById('dlg-settings');
    const btnCloseSettings = document.getElementById('btn-close-settings');
    const matchName = document.getElementById('match-name');
    const matchMeter = document.getElementById('match-meter');
    const matchScore = document.getElementById('match-score');

    document.querySelectorAll('.preset').forEach(b=>{
      b.addEventListener('click', ()=>{ msEl.value = b.dataset.ms; });
    });

    btnSettings.onclick = ()=> dlgSettings.showModal();
    btnCloseSettings.onclick = ()=> dlgSettings.close();

    async function initOPFS() {
      if (!opfsRoot) {
        opfsRoot = await navigator.storage.getDirectory();
        try { libDir = await opfsRoot.getDirectoryHandle(LIB_DIR, { create:true }); }
        catch(_) { /* noop */ }
      }
    }
    async function listFiles() {
      await initOPFS();
      fileList.innerHTML = '';
      let count = 0;
      for await (const [name, handle] of libDir.entries()) {
        if (handle.kind === 'file') {
          const li = document.createElement('li'); li.textContent = name;
          fileList.appendChild(li);
          count++;
        }
      }
      libcount.textContent = 'Libreria: ' + count;
    }

    async function ensureAudio() {
      if (audioCtx) return;
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio:true });
      source = audioCtx.createMediaStreamSource(mediaStream);
      analyser = audioCtx.createAnalyser();
      analyser.fftSize = 2048;
      source.connect(analyser);
    }

    function setLive(on) { liveDot.classList.toggle('live', !!on); }
    function setMode(newMode) {
      if (newMode === runningMode) return;
      stopAll();
      runningMode = newMode;
      btnRecord.disabled = newMode === 'listen';
      btnListen.disabled = newMode === 'record';
      setLive(!!newMode);
    }

    function stopAll() {
      if (rafId){ cancelAnimationFrame(rafId); rafId=null; }
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        try { mediaRecorder.stop(); } catch(_) {}
      }
      setLive(false);
      runningMode = null;
      btnRecord.disabled = false; btnListen.disabled = false;
    }

    function movingAverage(arr, win) {
      const out = new Float32Array(arr.length);
      let sum = 0; let q = [];
      for (let i=0;i<arr.length;i++){
        const v = Math.abs(arr[i]);
        q.push(v); sum += v;
        if (q.length > win) sum -= q.shift();
        out[i] = sum / q.length;
      }
      return out;
    }
    function resampleAvg(arr, targetLen) {
      const n = arr.length;
      const out = new Float32Array(targetLen);
      for (let i=0;i<targetLen;i++){
        const start = Math.floor(i * n / targetLen);
        const end = Math.floor((i+1) * n / targetLen);
        let s=0, c=0;
        for (let j=start;j<end;j++){ s += arr[j]; c++; }
        out[i] = c ? (s/c) : 0;
      }
      return out;
    }
    function normalize(v) {
      let m=0; for (let i=0;i<v.length;i++) m+=v[i]; m/=v.length;
      let s=0; for (let i=0;i<v.length;i++){ const d=v[i]-m; s+=d*d; }
      s = Math.sqrt(s)||1;
      const out = new Float32Array(v.length);
      for (let i=0;i<v.length;i++) out[i]=(v[i]-m)/s;
      return out;
    }
    function dot(a,b){ let s=0; for (let i=0;i<a.length;i++) s+=a[i]*b[i]; return s; }
    function rotate(v, shift){
      const n=v.length, out=new Float32Array(n);
      for(let i=0;i<n;i++){ out[(i+shift+n)%n]=v[i]; }
      return out;
    }
    function similarity(a,b){
      let best=-1;
      for(let sh=-8; sh<=8; sh++){
        const rr = rotate(b, sh);
        const s = dot(a, rr) / a.length;
        if (s>best) best=s;
      }
      return Math.max(0, Math.min(1, (best+1)/2));
    }
    function computeFingerprint(float32, sr, targetMs){
      const need = Math.max(1, Math.floor(sr * (targetMs/1000)));
      let buf = float32;
      if (buf.length > need){
        const start = Math.floor((buf.length - need)/2);
        buf = buf.subarray(start, start+need);
      }
      const win = Math.max(1, Math.floor(sr * (5/1000)));
      const env = movingAverage(buf, win);
      const ds = resampleAvg(env, 64);
      return normalize(ds);
    }

    async function decodeBlobToFloat32(blob) {
      const arr = await blob.arrayBuffer();
      const tmpCtx = audioCtx || new (window.AudioContext||window.webkitAudioContext)();
      const audioBuf = await tmpCtx.decodeAudioData(arr);
      return audioBuf.getChannelData(0).slice(0);
    }

    async function loadLibraryFingerprints() {
      library.length = 0;
      await initOPFS();
      for await (const [name, handle] of libDir.entries()) {
        if (handle.kind === 'file' && name.toLowerCase().endsWith('.webm')) {
          try {
            const f = await libDir.getFileHandle(name);
            const file = await f.getFile();
            const f32 = await decodeBlobToFloat32(file);
            const fp = computeFingerprint(f32, (audioCtx||{sampleRate:44100}).sampleRate || 44100, parseInt(msEl.value||'500'));
            library.push({ name: name.replace(/\.webm$/i,''), fp, msOriginal: f32.length });
          } catch (e) { console.warn('Impossibile decodificare', name, e); }
        }
      }
      libcount.textContent = 'Libreria: ' + library.length;
    }

    const ring = { data: new Float32Array(44100*2), writeIdx: 0, sr: 44100 };
    function pushToRing(arr){
      if (!arr) return;
      const n = arr.length, N = ring.data.length;
      for (let i=0;i<n;i++){
        ring.data[(ring.writeIdx+i)%N] = arr[i];
      }
      ring.writeIdx = (ring.writeIdx + n) % N;
    }
    function snapshotMs(ms){
      const N = ring.data.length;
      const need = Math.min(N, Math.floor(ring.sr * (ms/1000)));
      const out = new Float32Array(need);
      let idx = (ring.writeIdx - need + N) % N;
      for (let i=0;i<need;i++){ out[i]=ring.data[(idx+i)%N]; }
      return out;
    }

    function drawScopeAndMatch() {
      const buf = new Float32Array(analyser.fftSize);
      analyser.getFloatTimeDomainData(buf);
      pushToRing(buf);

      let sum=0; for (let i=0;i<buf.length;i++){ sum += buf[i]*buf[i]; }
      const rms = Math.sqrt(sum/buf.length);
      level.textContent = 'RMS: ' + rms.toFixed(2);

      const u8 = new Uint8Array(analyser.fftSize);
      analyser.getByteTimeDomainData(u8);
      ctx2d.clearRect(0,0,scope.width,scope.height);
      ctx2d.strokeStyle = '#93c5fd';
      ctx2d.lineWidth = 2;
      ctx2d.beginPath();
      const h = scope.height, w = scope.width;
      for (let i=0;i<u8.length;i++){
        const x = i/(u8.length-1)*w;
        const y = (1 - (u8[i]/255))*h;
        if (i===0) ctx2d.moveTo(x,y); else ctx2d.lineTo(x,y);
      }
      ctx2d.stroke();

      const thr = parseFloat(thrEl.value||'0.08');
      if (rms >= thr && runningMode === 'listen' && library.length>0){
        const ms = Math.max(50, parseInt(msEl.value||'500'));
        const snap = snapshotMs(ms);
        const fpLive = computeFingerprint(snap, ring.sr, ms);
        let best = {name:'—', score:0};
        for (const item of library){
          const s = similarity(fpLive, item.fp);
          if (s > best.score) best = {name:item.name, score:s};
        }
        const mt = parseFloat(matchThrEl.value||'0.85');
        matchName.textContent = best.score>=mt ? `Match: ${best.name}` : 'Nessun match';
        document.getElementById('match-meter').style.width = Math.round(best.score*100) + '%';
        document.getElementById('match-score').textContent = best.score.toFixed(2);
        if (best.score>=mt) { ctx2d.fillStyle = 'rgba(34,197,94,.18)'; } else { ctx2d.fillStyle = 'rgba(96,165,250,.14)'; }
        ctx2d.fillRect(0,0,w,h);
      } else {
        matchName.textContent = '—';
        document.getElementById('match-meter').style.width = '0%';
        document.getElementById('match-score').textContent = '0.00';
      }

      rafId = requestAnimationFrame(drawScopeAndMatch);
    }

    async function startListen() {
      await ensureAudio();
      ring.sr = audioCtx.sampleRate || 44100;
      await loadLibraryFingerprints();
      drawScopeAndMatch();
    }

    async function startRecord() {
      await ensureAudio();
      chunks = [];
      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: 'audio/webm' });
      mediaRecorder.ondataavailable = (e)=> { if (e.data.size>0) chunks.push(e.data); };
      mediaRecorder.onstop = async ()=>{ dlgSave.showModal(); };
      mediaRecorder.start();
      drawScopeAndMatch();
      const durMs = Math.max(50, parseInt(msEl.value||'500'));
      setTimeout(()=>{ try { mediaRecorder.stop(); } catch(_) {} }, durMs);
    }

    document.getElementById('btn-do-save').addEventListener('click', async ()=>{
      try {
        const name = (saveName.value || ('sample-' + Date.now())) + '.webm';
        await initOPFS();
        const fh = await libDir.getFileHandle(name, { create:true });
        const w = await fh.createWritable();
        const blob = new Blob(chunks, { type:'audio/webm' });
        await w.write(blob); await w.close();
        dlgSave.close(); saveName.value=''; chunks=[];
        await listFiles();
        try {
          const f32 = await (await (new Response(blob)).blob()).arrayBuffer();
        } catch(e){}
      } catch (err) { console.error(err); alert('Errore nel salvataggio.'); }
    });
    document.getElementById('btn-cancel-save').addEventListener('click', ()=>{ dlgSave.close(); saveName.value=''; chunks=[]; });

    document.getElementById('btn-delete-all').addEventListener('click', async ()=>{
      if (!confirm('Confermi l’eliminazione di tutti i file salvati?')) return;
      try {
        await initOPFS();
        const toDelete = [];
        for await (const [name, handle] of libDir.entries()) {
          if (handle.kind === 'file') toDelete.push(name);
        }
        for (const n of toDelete) {
          await libDir.removeEntry(n);
        }
        await listFiles();
        library.length = 0;
        libcount.textContent = 'Libreria: 0';
        alert('Tutti i file sono stati eliminati.');
      } catch (e) { console.error(e); alert('Errore durante la cancellazione.'); }
    });

    document.getElementById('btn-reload-lib').addEventListener('click', async ()=>{
      await loadLibraryFingerprints();
      alert('Libreria ricaricata.');
    });

    btnRecord.addEventListener('click', async ()=>{
      if (runningMode === 'listen') return;
      setMode('record');
      try { await startRecord(); } catch (e) { console.error(e); alert('Accesso microfono negato o non disponibile.'); stopAll(); }
    });
    btnListen.addEventListener('click', async ()=>{
      if (runningMode === 'record') return;
      setMode('listen');
      try { await startListen(); } catch (e) { console.error(e); alert('Accesso microfono negato o non disponibile.'); stopAll(); }
    });

    (async ()=>{
      await initOPFS();
      await listFiles();
      stopAll();
    })();
  </script>
</body>
</html>
